<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <h1>二叉树的最大深度</h1>
  <ul>
    <li>解法一：深度优先遍历，递归函数，进过每个函数体时，选出左右子树中最大深度的数 + 1 （贪心算法，遍历每个节点，可用深度，也可用广度）</li>
    <li>解法二：广度优先，非递归，每次记录每一次进入队列的节点数是多少（获取当前队列的长度 n），然后循环n（unshift），每层循环掉就+1</li>
  </ul>
  <h1>验证搜索二叉树</h1>
  <ul>
    <li>递归法，每个节点的值和左右子节点对比 （深度，广度都可以，目的是遍历每个节点，保证每个节点是最小搜索树）</li>
    <li>中序遍历，遍历得到的数组结果一定是从小到大排列的，否则不是搜索二叉树，所以每次进入循环时得到的值可以跟数组中的最后一个值相比，小于则不是，大于则是</li>
  </ul>
  <h1>对称二叉树</h1>
  <ul>
    <li>递归法，将树一开始取出 左右子节点p,q，然后判断值是否相等 ，递归判断p.left == q.right 和 递归判断 p.right == q.left </li>
    <li>非递归，上面方式的修改版，借用队列，每次取出两个节点对比值，每次入队列时，将 p.left 和 q.right 放在相邻的位置，p.right q.left同理</li>
  </ul>
  <h1>二叉树的层级遍历</h1>
  <ul>
    <li>广度优先遍历，解法与二叉树最大深度的解法二相似</li>
  </ul>
  <h1>高度平衡二叉树</h1>
  <ul>
    <li>递归，排序好的数组满足中序遍历，选取中间的节点（偶数，偏左偏右皆可）作为根节点，左边的数组是左子树，右边的数组是右子树，将左边数组和右边数组递归，得到高度平衡二叉树</li>
  </ul>
</body>
</html>