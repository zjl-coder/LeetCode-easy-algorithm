<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <h1>反转字符串</h1>
  <ul>
    <li>双指针：一个在前一个在后，交换字符位置</li>
    <li>入栈</li>
    <li>unshitf 插入数组前面</li>
  </ul>
  <h1>整数反转</h1>
  <ul>
    <li>字符串化</li>
    <li>数学计算法，迭代，整数 % 10 取得个位数n1 和 Math.floor(整数/10) 剩下的整数，再取出各位数n2, 拼装 n1 * 10 + n2 ,循环累计，直到整数变成0停止循环</li>
  </ul>
  <h1>字符串中的第一个唯一字符</h1>
  <ul>
    <li>哈希表存储频数：按顺序存每个字符的次数，最后取出第一个字符为1的那个字符，两次遍历，一次存入哈希表，一次遍历哈希表</li>
    <li>哈希表存储索引：第一次出现的字符 对应的值存它的索引，如果再次出现则 值置位 -1，最后找出第一个值不为-1的那个字符，两次遍历，一次存入哈希表，一次遍历哈希表</li>
  </ul>
  <h1>有效的字母异位词</h1>
  <ul>
    <li>排序，比较两个字符串是否相等</li>
    <li>哈希表，第一个字符串先根据字符出现的次数填入哈希表，遍历第二个字符串的是否 判断是否有在哈希表中，没有就不是异位词，有就对应字符次数减1，如果第二个字符串遍历完，则遍历哈希表是否有不为 0 的字符（有可能大于0，也有可能小于0），有则不是</li>
  </ul>
  <h1>验证回文串</h1>
  <ul>
    字符串有空格和逗号
    <li>删除空格和逗号，然后判断按照普通方式判断是否是回文（两种方式：1、同步双指针法，2、翻转字符串与原字符串是否相等）</li>
    <li>双指针法：一个在前一个在后，同时向中间移动，每次判断是否相等，直到指针相遇（遇到空格或者符号，指针再继续移动一步）</li>
  </ul>
  <h1>字符串转换整数 (atoi)</h1>
  <ul>
    <li>自动机：删除前面的空格，判断第一个字符是否是 “-”，是则用状态变量存起来，不是的话判断是否是数字，不是就返回0，是就一直判断到非数字的那个字位置，判断状态变量是否返回负数。</li>
  </ul>
  <h1>实现 strStr(str1,str2)</h1>
  <ul>
    找出str2 在str1 首次出现的位置，没有返回-1；
    <li>使用indexOf</li>
    <li>计算str2的长度，str1 逐个取出后续相同长度的子串比较是否相等</li>
    <li>双指针法：str1 指针移到与 str2 第一个字符相同的位置，记录下str1 的 index，然后两个指针一直往下移动，如果中间出现不相同的字符，则 str2 指针回到头位置，str1指针继续找到某个与str2 头相同的位置，循环</li>
  </ul>
  <h1>外观数列</h1>
  <ul>
    <li>遍历：判断指针的下一个相邻字符是否与当前字符相同，相同则加+1，指针更新为下一个字符，不同则将当前的次数 和 指针字符推入数组，先推入个数再推入本数，移动指针。 </li>
  </ul>
  <h1>最长公共前缀</h1>
  <ul>
    <li>横向扫描：遍历第一个字符串（把第一个字符串当成最长前缀），遍历第二个字符串，更新最长前缀，知道遍历完数组中的所有字符串</li>
    <li>纵向扫描：指针指向每个字符串相同的位置（字符串的每个列），判断字符是否相同，相同则推入数组，不同则返回数组</li>
    <li>分治：递归实现，将数组分解为两个子数组，分别求最长子串前缀，然后再比较两个最长子串前缀，得出最终前缀</li>
    <li>二分查找：先将字符串长度最短的那个字符串 str，将str与所有字符串比较，如果不符合，就取出 str 的前半段 与所有字符串比较，如果符合，则 取 str的后半段的一般位置跟所有字符串比较，二分法，直到确定某个段匹配所有字符串或者不匹配</li>
  </ul>
</body>
</html>